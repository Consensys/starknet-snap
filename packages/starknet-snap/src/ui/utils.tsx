import { TokenStateManager } from '../state/token-state-manager';
import { FeeToken } from '../types/snapApi';
import type {
  FormattedCallData,
  Network,
  TransactionRequest,
} from '../types/snapState';
import {
  BlockIdentifierEnum,
  DEFAULT_DECIMAL_PLACES,
} from '../utils/constants';
import { getBalance } from '../utils/starknetUtils';
import type { ExecuteTxnUIErrors } from './components';
import { ExecuteTxnUI } from './components';
import { LoadingUI } from './fragments/LoadingUI';
import type { TokenTotals } from './types';

/**
 * Accumulate the total amount for all tokens involved in calls and fees.
 *
 * @param calls - The array of FormattedCallData object.
 * @param maxFee - The maximum fee.
 * @param selectedFeeToken - The selected token symbol for fees.
 * @returns The accumulated totals for each token.
 */
export const accumulateTotals = (
  calls: FormattedCallData[],
  maxFee: string,
  selectedFeeToken: string,
): TokenTotals => {
  return calls.reduce(
    (acc, call) => {
      if (call.tokenTransferData) {
        const amount = BigInt(call.tokenTransferData.amount); // Convert to BigInt
        if (!acc[call.tokenTransferData.symbol]) {
          acc[call.tokenTransferData.symbol] = {
            amount: BigInt(0),
            decimals: call.tokenTransferData.decimals,
          };
        }
        acc[call.tokenTransferData.symbol].amount += amount;
      }
      return acc;
    },
    {
      // We derive decimals based on the fee token. Currently, both supported fee tokens, ETH and STRK, use the standard 18 decimals.
      // Therefore, we use DEFAULT_DECIMAL_PLACES set to 18 here. If additional fee tokens with different decimals are introduced,
      // this logic should be updated to handle token-specific decimals dynamically.
      [selectedFeeToken]: {
        amount: BigInt(maxFee),
        decimals: DEFAULT_DECIMAL_PLACES,
      },
    },
  );
};

/**
 * Generate the interface for a ExecuteTxnUI
 *
 * @param request - TransactionRequest
 * @returns A Promise that resolves to the interface ID generated by the Snap request.
 * The ID can be used for tracking or referencing the created interface.
 */
export async function generateExecuteTxnFlow(
  request: TransactionRequest, // Request must match props and include an `id`
) {
  const {
    signer,
    chainId,
    networkName,
    maxFee,
    calls,
    selectedFeeToken,
    includeDeploy,
  } = request;
  return await snap.request({
    method: 'snap_createInterface',
    params: {
      ui: (
        <ExecuteTxnUI
          signer={signer}
          chainId={chainId}
          networkName={networkName}
          maxFee={maxFee}
          calls={calls}
          selectedFeeToken={selectedFeeToken}
          includeDeploy={includeDeploy}
        />
      ),
      context: {
        request,
      },
    },
  });
}

/**
 * Update the interface for a ExecuteTxnUI
 *
 * @param id - Interface Id
 * @param request - TransactionRequest
 * @param errors
 * @param errors.errors
 */
export async function updateExecuteTxnFlow(
  id: string, // Interface Id to update
  request: TransactionRequest, // Props must include `id` and `interfaceId`
  errors?: { errors: ExecuteTxnUIErrors }, // Optional partial props for error handling or overrides
) {
  const {
    signer,
    chainId,
    networkName,
    maxFee,
    calls,
    selectedFeeToken,
    includeDeploy,
  } = request;
  // Perform the interface update
  await snap.request({
    method: 'snap_updateInterface',
    params: {
      id,
      ui: (
        <ExecuteTxnUI
          signer={signer}
          chainId={chainId}
          networkName={networkName}
          maxFee={maxFee}
          calls={calls}
          selectedFeeToken={selectedFeeToken}
          includeDeploy={includeDeploy}
          {...errors}
        />
      ),
    },
  });
}

export type UpdateInterfaceParams = {
  id: string;
  ui: JSX.Element;
};

/**
 *
 * @param id
 * @param ui
 */
export async function updateInterface(
  id: string,
  ui: JSX.Element,
): Promise<void> {
  await snap.request({
    method: 'snap_updateInterface',
    params: {
      id,
      ui,
    },
  });
}

/**
 *
 * @param id
 */
export async function renderLoading(id: string): Promise<void> {
  await updateInterface(id, <LoadingUI />);
}

/**
 * Checks if the provided address has sufficient funds in either STRK or ETH to cover
 * the total amount required for a set of contract calls and a suggested transaction fee.
 *
 * @param address - The wallet address to check balances for.
 * @param network - The network object, which includes information such as chainId.
 * @param calls - An array of contract call objects.
 * Each object should contain a contract address and an optional amount.
 * @param feeToken - Specifies the fee token type (either STRK or ETH) to use for the transaction fee.
 * @param suggestedMaxFee - The maximum transaction fee to consider, as a stringified bigint.
 * @returns Resolves to `true` if there are sufficient funds for the specified fee token
 * to cover both the total amounts in `calls` and the `suggestedMaxFee`; otherwise, `false`.
 */
export async function hasSufficientFunds(
  address: string,
  network: Network,
  calls: { contractAddress: string; amount?: string }[],
  feeToken: FeeToken,
  suggestedMaxFee: string,
): Promise<boolean> {
  const stateManager = new TokenStateManager();

  // Fetch STRK token details and balance
  const strkToken = await stateManager.getStrkToken({
    chainId: network.chainId,
  });
  const strkBalance = strkToken
    ? await getBalance(
        address,
        strkToken.address,
        network,
        BlockIdentifierEnum.Pending,
      )
    : '0';

  // Fetch ETH token details and balance
  const ethToken = await stateManager.getEthToken({ chainId: network.chainId });
  const ethBalance = ethToken
    ? await getBalance(
        address,
        ethToken.address,
        network,
        BlockIdentifierEnum.Pending,
      )
    : '0';

  // Initialize total amounts for STRK and ETH
  let totalStrkAmount = BigInt(0);
  let totalEthAmount = BigInt(0);

  // Calculate total STRK and ETH amounts from `calls`
  calls.forEach((call) => {
    const callAmount = BigInt(call.amount ?? '0');

    if (strkToken && call.contractAddress === strkToken.address) {
      totalStrkAmount += callAmount;
    } else if (ethToken && call.contractAddress === ethToken.address) {
      totalEthAmount += callAmount;
    }
  });

  // Add the `suggestedMaxFee` to the respective token amount
  const maxFee = BigInt(suggestedMaxFee);
  if (feeToken === FeeToken.STRK) {
    totalStrkAmount += maxFee;
  } else if (feeToken === FeeToken.ETH) {
    totalEthAmount += maxFee;
  }

  // Check that balances are sufficient
  const hasSufficientStrk = BigInt(strkBalance) >= totalStrkAmount;
  const hasSufficientEth = BigInt(ethBalance) >= totalEthAmount;

  // Return true only if the selected feeToken has sufficient funds
  return (
    (feeToken === FeeToken.STRK && hasSufficientStrk) ||
    (feeToken === FeeToken.ETH && hasSufficientEth)
  );
}
